#include <iostream>
#include <vector>
#include <numeric>
#include <unordered_map>

class UnionSet
{
public:
    UnionSet(int n) : parent(n), rank(n)
    {
        std::iota(parent.begin(), parent.end(), 0);
    }

    int find(int x)
    {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    void unite(int x, int y)
    {
        x = find(x);
        y = find(y);
        if (x != y)
        {
            if (rank[x] < rank[y])
            {
                parent[x] = y;
            }
            else
            {
                parent[y] = x;
                if (rank[x] == rank[y])
                    ++rank[x];
            }
        }
    }

private:
    std::vector<int> parent;
    std::vector<int> rank;
};

class Solution
{
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial)
    {
        int n = graph.size();
        UnionSet unionSet(n);
        for (int x = 0; x < n - 1; ++x)
        {
            for (int y = x + 1; y < n; ++y)
            {
                if (graph[x][y])
                    unionSet.unite(x, y);
            }
        }

        // first:连通分量中的节点数，second:连通分量中的恶意节点数
        std::unordered_map<int, std::pair<int, int>> nodeCnt;
        // 统计每个连通分量中的节点数
        for (int x = 0; x < n; ++x)
            ++nodeCnt[unionSet.find(x)].first;
        // 统计每个连通分量中的恶意节点数
        for (int x : initial)
            ++nodeCnt[unionSet.find(x)].second;

        // 计算M(initial)
        int m = 0;
        for (auto it = nodeCnt.begin(); it != nodeCnt.end(); ++it)
        {
            const auto& [cnt, mal] = it->second;
            if (mal)
                m += cnt;
        }

        int ans = initial[0], minM = m;
        for (int x : initial)
        {
            int res = m;
            const auto& [cnt, mal] = nodeCnt[unionSet.find(x)];
            if (mal == 1)
                res -=  cnt;
            if (res < minM)
            {
                ans = x;
                minM = res;
            }
            else if (res == minM && x < ans)
            {
                ans = x;
            }
        }

        return ans;
    }
};

int main()
{
    std::cout << "For Kirie!" << std::endl;
    return 0;
}
