#include <iostream>
#include <vector>
#include <unordered_set>
#include <functional>

class Solution
{
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial)
    {
        int n = graph.size(), m = initial.size();
        std::unordered_set<int> malware(initial.begin(), initial.end());
        std::vector<bool> visit(n);
        int maxReduce = -1, ans = -1;
        for (int i = 0; i < m; ++i)
        {
            std::fill(visit.begin(), visit.end(), false);
            visit[initial[i]] = true;
            int x = initial[i], reduce = 1;
            for (int y = 0; y < n; ++y)
            {
                if (graph[x][y] && !visit[y])
                {
                    int visitCnt = 0;
                    if (!dfs(graph, y, visit, visitCnt, malware))    // 该连通分量中没有恶意节点
                    {
                        reduce += visitCnt;
                    }
                }
            }
            if (reduce > maxReduce)
            {
                maxReduce = reduce;
                ans = x;
            }
            else if (reduce == maxReduce && x < ans)
            {
                ans = x;
            }
        }
        return ans;
    }

    bool dfs(const std::vector<std::vector<int>>& graph, int x, std::vector<bool>& visit, int& visitCnt,
             const std::unordered_set<int>& malware)
    {
        bool visitMal = malware.find(x) != malware.end();
        visit[x] = true;
        ++visitCnt;
        for (int y = 0; y < graph.size(); ++y)
        {
            if (graph[x][y] && !visit[y])
            {
                visitMal |= dfs(graph, y, visit, visitCnt, malware);
            }
        }
        return visitMal;
    }
};

class Solution2
{
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial)
    {
        int n = graph.size();
        std::unordered_set<int> malware(initial.begin(), initial.end());
        std::vector<bool> visit(n, false);
        int nodeId, size;
        std::function<void(int)> dfs = [&](int x) {
            visit[x] = true;
            ++size;
            for (int y = 0; y < n; ++y)
            {
                if (graph[x][y] == 0)
                    continue;
                if (malware.find(y) != malware.end())   // y是恶意节点
                {
                    if (nodeId != -2 && nodeId != y)
                    {
                        // 状态机
                        // -1:初始状态 x:找到恶意节点x -2:找到多个恶意节点
                        nodeId = nodeId == -1 ? y : -2;
                    }
                }
                else if (!visit[y])
                {
                    dfs(y);
                }
            }
        };

        std::unordered_map<int, int> cnt;
        for (int i = 0; i < n; ++i)
        {
            if (!visit[i] && malware.find(i) == malware.end())  // 未访问过i，且i不是恶意节点
            {
                nodeId = -1;    // 初始化状态
                size = 0;
                dfs(i);
                if (nodeId >= 0)
                {
                    // 只找到一个在initial中的节点，删除nodeId可以让size个点不被感染
                    cnt[nodeId] += size;
                }
            }
        }

        int maxCnt = 0, minNodeId = 0;
        for (auto it = cnt.begin(); it != cnt.end(); ++it)
        {
            nodeId = it->first;
            int c = it->second;
            if (c > maxCnt || (c == maxCnt && nodeId < minNodeId))
            {
                maxCnt = c;
                minNodeId = nodeId;
            }
        }
        if (cnt.empty())
            return *std::min_element(initial.begin(), initial.end());
        else
            return minNodeId;
    }
};

int main()
{
    std::cout << "For Kirie!" << std::endl;
    return 0;
}
